var subjects = new ActiveXObject("Scripting.Dictionary");
var answers = new ActiveXObject("Scripting.Dictionary");


subjects.Add("ADSJ", ["Java program to create generic class with bounded types.java",
    "Java program to create generic class with one type parameter..java",
    "Java program to create generic class with two type parameters.java",
    "Java program to demonstrate Deque operations.java",
    "Java program to demonstrate non generic method.java",
    "Java program to demonstrate usage of functions using linked list.java",
    "Java program to demonstrate use of comparator in sorting the elements using treeset.java",
    "Java program to demonstrate wild cards.java",
    "Java program to display numbers in ascending order using priority queue.java",
    "Java program to display unique words having length greater than 3 from file in ascending order.java",
    "Java program to generate n binary numbers using queue.java",
    "Java program to implement inheritance in Java.java",
    "Java program to implement linked list.java",
    "Java program to implement max heap using priority queue.java",
    "Java program to implement operations on binary search tree.java",
    "Java program to implement operations on linear probing.java",
    "Java program to implement queue using array implementation.java",
    "Java program to implement queue using linked list.java",
    "Java program to implement sorted chain.java",
    "Java program to implement stack operations using array list.java",
    "Java program to implement stack using array implementation.java",
    "Java program to implement stack using linked list.java",
    "Java program to perform add, remove, display operations on hash set.java"
    ]);

var ADSJanswers = ['// Define a generic class with a bounded type parameter T\npublic class Box<T extends Number> {\n    private T content;\n\n    // Constructor to initialize the box with content\n    public Box(T content) {\n        this.content = content;\n    }\n\n    // Method to get the content of the box\n    public T getContent() {\n        return content;\n    }\n\n    // Method to set the content of the box\n    public void setContent(T content) {\n        this.content = content;\n    }\n\n    // Method to display the content of the box\n    public void displayContent() {\n        System.out.println("Content: " + content);\n    }\n\n    // Method to get the double value of the content\n    public double getDoubleValue() {\n        return content.doubleValue();\n    }\n\n    public static void main(String[] args) {\n        // Create a Box for Integer\n        Box<Integer> integerBox = new Box<>(123);\n        integerBox.displayContent(); // Output: Content: 123\n        System.out.println("Double Value: " + integerBox.getDoubleValue()); // Output: Double Value: 123.0\n\n        // Create a Box for Double\n        Box<Double> doubleBox = new Box<>(456.78);\n        doubleBox.displayContent(); // Output: Content: 456.78\n        System.out.println("Double Value: " + doubleBox.getDoubleValue()); // Output: Double Value: 456.78\n\n        // The following line would cause a compile-time error\n        // Box<String> stringBox = new Box<>("Hello"); // Error: Type parameter \'java.lang.String\' is not within its bound; should extend \'java.lang.Number\'\n    }\n}\n',
    '// Define a generic class with one type parameter T\npublic class Box<T> {\n    private T data;\n\n    // Constructor to initialize the box with a data\n    public Box(T data) {\n        this.data = data;\n    }\n\n    // Method to get the data of the box\n    public T getContent() {\n        return data;\n    }\n\n    // Method to set the data of the box\n    public void setContent(T data) {\n        this.data = data;\n    }\n\n    // Method to display the data of the box\n    public void displayContent() {\n        System.out.println("Content: " + data);\n    }\n\n    public static void main(String[] args) {\n        // Create a Box for Integer\n        Box<Integer> integerBox = new Box<>(123);\n        integerBox.displayContent(); // Output: Content: 123\n\n        // Create a Box for String\n        Box<String> stringBox = new Box<>("Hello, Generics!");\n        stringBox.displayContent(); // Output: Content: Hello, Generics!\n\n        // Create a Box for Double\n        Box<Double> doubleBox = new Box<>(456.78);\n        doubleBox.displayContent(); // Output: Content: 456.78\n    }\n}\n',
    '// Define a generic class with two type parameters T and U\npublic class Pair<T, U> {\n    private T first;\n    private U second;\n\n    // Constructor to initialize the pair with two values\n    public Pair(T first, U second) {\n        this.first = first;\n        this.second = second;\n    }\n\n    // Method to get the first value of the pair\n    public T getFirst() {\n        return first;\n    }\n\n    // Method to set the first value of the pair\n    public void setFirst(T first) {\n        this.first = first;\n    }\n\n    // Method to get the second value of the pair\n    public U getSecond() {\n        return second;\n    }\n\n    // Method to set the second value of the pair\n    public void setSecond(U second) {\n        this.second = second;\n    }\n\n    // Method to display the values of the pair\n    public void displayPair() {\n        System.out.println("First: " + first + ", Second: " + second);\n    }\n\n    public static void main(String[] args) {\n        // Create a Pair for Integer and String\n        Pair<Integer, String> pair1 = new Pair<>(1, "One");\n        pair1.displayPair(); // Output: First: 1, Second: One\n\n        // Create a Pair for String and Double\n        Pair<String, Double> pair2 = new Pair<>("Price", 99.99);\n        pair2.displayPair(); // Output: First: Price, Second: 99.99\n\n        // Create a Pair for Boolean and Character\n        Pair<Boolean, Character> pair3 = new Pair<>(true, \'A\');\n        pair3.displayPair(); // Output: First: true, Second: A\n    }\n}\n',
    'import java.util.Deque;\nimport java.util.LinkedList;\n\npublic class DequeExample {\n    public static void main(String[] args) {\n        // Create a Deque\n        Deque<String> deque = new LinkedList<>();\n\n        // Adding elements at the tail\n        deque.offerLast("One");\n        deque.offerLast("Two");\n        deque.offerLast("Three");\n        System.out.println("Deque after adding elements at the tail: " + deque);\n\n        // Adding elements at the head\n        deque.offerFirst("Zero");\n        System.out.println("Deque after adding an element at the head: " + deque);\n\n        // Removing elements from the tail\n        String removedTail = deque.pollLast();\n        System.out.println("Removed element from the tail: " + removedTail);\n        System.out.println("Deque after removing an element from the tail: " + deque);\n\n        // Removing elements from the head\n        String removedHead = deque.pollFirst();\n        System.out.println("Removed element from the head: " + removedHead);\n        System.out.println("Deque after removing an element from the head: " + deque);\n\n        // Peeking elements at the tail and head\n        String peekTail = deque.peekLast();\n        System.out.println("Peeked element at the tail: " + peekTail);\n        String peekHead = deque.peekFirst();\n        System.out.println("Peeked element at the head: " + peekHead);\n    }\n}\n',
    'public class NonGenericMethodExample {\n    // Non-generic method that prints elements of an integer array\n    public void printArray(int[] array) {\n        for (int element : array) {\n            System.out.print(element + " ");\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        NonGenericMethodExample example = new NonGenericMethodExample();\n\n        // Create an integer array\n        int[] intArray = {1, 2, 3, 4, 5};\n\n        // Call the non-generic method to print the array\n        example.printArray(intArray);\n    }\n}\n',
    'import java.util.LinkedList;\n\npublic class LinkedListExample {\n\n    public static void main(String[] args) {\n        // Create a LinkedList\n        LinkedList<String> linkedList = new LinkedList<>();\n\n        // Add elements to the LinkedList\n        linkedList.add("One");\n        linkedList.add("Two");\n        linkedList.add("Three");\n        linkedList.add("Four");\n        linkedList.add("Five");\n        System.out.println("Initial LinkedList: " + linkedList);\n\n        // Insert an element at a specific position\n        linkedList.add(2, "InsertedElement");\n        System.out.println("LinkedList after insertion: " + linkedList);\n\n        // Remove an element from the LinkedList\n        linkedList.remove("Three");\n        System.out.println("LinkedList after removal: " + linkedList);\n\n        // Search for an element in the LinkedList\n        String searchFor = "Two";\n        if (linkedList.contains(searchFor)) {\n            System.out.println("Element \'" + searchFor + "\' is found in the list.");\n        } else {\n            System.out.println("Element \'" + searchFor + "\' is not found in the list.");\n        }\n    }\n}\n',
    'import java.util.Comparator;\nimport java.util.TreeSet;\n\n// Define a class representing a Book\nclass Book {\n    private String title;\n    private String author;\n    private Integer year;\n\n    // Constructor\n    public Book(String title, String author, int year) {\n        this.title = title;\n        this.author = author;\n        this.year = year;\n    }\n\n    // Getter methods\n    public String getTitle() {\n        return title;\n    }\n\n    public String getAuthor() {\n        return author;\n    }\n\n    public int getYear() {\n        return year;\n    }\n\n    // Override toString method to print Book details\n    @Override\n    public String toString() {\n        return "[" + title + " by " + author + " (" + year + ")]";\n    }\n}\n\npublic class TreeSetComparatorExample {\n    public static void main(String[] args) {\n        // Create a TreeSet with a custom Comparator to sort books by title\n        TreeSet<Book> booksByTitle = new TreeSet<>((p1,p2)->p1.getYear() -p2.getYear());\n\n        // Add books to the TreeSet\n        booksByTitle.add(new Book("Java Programming", "John Doe", 2019));\n        booksByTitle.add(new Book("Python Basics", "Alice Smith", 2020));\n        booksByTitle.add(new Book("JavaScript Fundamentals", "Bob Johnson", 2018));\n\n        // Print the sorted books by title\n        System.out.println("Books sorted by title:");\n        for (Book book : booksByTitle) {\n            System.out.println(book);\n        }\n\n        // Create a TreeSet with a custom Comparator to sort books by year\n        TreeSet<Book> booksByYear = new TreeSet<>(Comparator.comparing(Book::getYear));\n\n        // Add books to the TreeSet\n        booksByYear.add(new Book("Java Programming", "John Doe", 2019));\n        booksByYear.add(new Book("Python Basics", "Alice Smith", 2020));\n        booksByYear.add(new Book("JavaScript Fundamentals", "Bob Johnson", 2018));\n\n        // Print the sorted books by year\n        System.out.println("\\nBooks sorted by year:");\n        for (Book book : booksByYear) {\n            System.out.println(book);\n        }\n    }\n}\n',
    'import java.util.ArrayList;\nimport java.util.List;\n\npublic class WildcardExample {\n\n    // Method with an unbounded wildcard\n    public static void printList(List<?> list) {\n        for (Object elem : list) {\n            System.out.print(elem + " ");\n        }\n        System.out.println();\n    }\n\n    // Method with an upper bounded wildcard\n    public static double sumOfList(List<? extends Number> list) {\n        double sum = 0.0;\n        for (Number num : list) {\n            sum += num.doubleValue();\n        }\n        return sum;\n    }\n\n    // Method with a lower bounded wildcard\n    public static void addNumbers(List<? super Integer> list) {\n        list.add(1);\n        list.add(2);\n        list.add(3);\n    }\n\n    public static void main(String[] args) {\n        // Demonstrating unbounded wildcard\n        List<String> stringList = new ArrayList<>();\n        stringList.add("One");\n        stringList.add("Two");\n        stringList.add("Three");\n        printList(stringList); // Output: One Two Three \n\n        // Demonstrating upper bounded wildcard\n        List<Integer> integerList = new ArrayList<>();\n        integerList.add(10);\n        integerList.add(20);\n        integerList.add(30);\n        System.out.println("Sum: " + sumOfList(integerList)); // Output: Sum: 60.0\n\n        List<Double> doubleList = new ArrayList<>();\n        doubleList.add(1.1);\n        doubleList.add(2.2);\n        doubleList.add(3.3);\n        System.out.println("Sum: " + sumOfList(doubleList)); // Output: Sum: 6.6\n\n        // Demonstrating lower bounded wildcard\n        List<Number> numberList = new ArrayList<>();\n        addNumbers(numberList);\n        printList(numberList); // Output: 1 2 3\n    }\n}\n',
    'import java.util.PriorityQueue;\n\npublic class PriorityQueueExample {\n    public static void main(String[] args) {\n        // Create a priority queue\n        PriorityQueue<Integer> priorityQueue = new PriorityQueue<>();\n\n        // Add numbers to the priority queue\n        priorityQueue.offer(10);\n        priorityQueue.offer(5);\n        priorityQueue.offer(20);\n        priorityQueue.offer(8);\n        priorityQueue.offer(15);\n\n        // Display numbers in ascending order\n        System.out.println("Numbers in ascending order:");\n        while (!priorityQueue.isEmpty()) {\n            System.out.println(priorityQueue.poll());\n        }\n    }\n}\n',
    'import java.io.*;\nimport java.util.*;\nimport java.util.regex.*;\n\npublic class UniqueWordsFromFile {\n    public static void main(String[] args) {\n        // File path to the text file\n        String filePath = "example.txt";\n\n        // Set to store unique words in sorted order\n        Set<String> uniqueWords = new TreeSet<>();\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                // Use regex to split words by non-alphabetic characters\n                String[] words = line.split("\\\\W+");\n                for (String word : words) {\n                   \n                    // Convert word to lowercase to handle case insensitivity\n                    word = word.toLowerCase();\n\n                    // Check if the word length is greater than 3\n                    if (word.length() > 3) {\n                        uniqueWords.add(word);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // Print the unique words in ascending order\n        for (String word : uniqueWords) {\n            System.out.println(word);\n        }\n    }\n}\n',
    'import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class BinaryNumberGenerator {\n\n    // Method to generate binary numbers up to n\n    public static void generateBinaryNumbers(int n) {\n        // Create a queue to store binary numbers\n        Queue<String> queue = new LinkedList<>();\n        \n        // Start with 1 as the first binary number\n        queue.offer("1");\n        \n        // Generate binary numbers up to n\n        for (int i = 0; i < n; i++) {\n            // Dequeue the front binary number\n            String binaryNumber = queue.poll();\n            \n            // Print the dequeued binary number\n            System.out.println(binaryNumber);\n            \n            // Enqueue binary number with \'0\' appended\n            queue.offer(binaryNumber + "0");\n            \n            // Enqueue binary number with \'1\' appended\n            queue.offer(binaryNumber + "1");\n        }\n    }\n\n    public static void main(String[] args) {\n        // Number of binary numbers to generate\n        int n = 5;\n\n        // Generate binary numbers\n        System.out.println("Binary numbers up to " + n + ":");\n        generateBinaryNumbers(n);\n    }\n}\n',
    '// Generic base class\npublic class Box<T> {\n    private T item;\n\n    public Box(T item) {\n        this.item = item;\n    }\n\n    public T getItem() {\n        return item;\n    }\n\n    public void setItem(T item) {\n        this.item = item;\n    }\n\n    @Override\n    public String toString() {\n        return "Box{" +\n                "item=" + item +\n                \'}\';\n    }\n}\n\n// Subclass with an additional property\npublic class ColoredBox<T> extends Box<T> {\n    private String color;\n\n    public ColoredBox(T item, String color) {\n        super(item);\n        this.color = color;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    @Override\n    public String toString() {\n        return "ColoredBox{" +\n                "item=" + getItem() +\n                ", color=\'" + color + \'\\\'\' +\n                \'}\';\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        // Creating a generic Box for Integer items\n        Box<Integer> integerBox = new Box<>(123);\n        System.out.println(integerBox);\n\n        // Creating a ColoredBox for String items\n        ColoredBox<String> coloredStringBox = new ColoredBox<>("Hello", "Red");\n        System.out.println(coloredStringBox);\n\n        // Creating a ColoredBox for Double items\n        ColoredBox<Double> coloredDoubleBox = new ColoredBox<>(45.67, "Blue");\n        System.out.println(coloredDoubleBox);\n    }\n}\n',
    '// Generic Node class\nclass Node<T> {\n    T data;\n    Node<T> next;\n\n    // Constructor\n    public Node(T data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\n// Generic LinkedList class\npublic class LinkedList<T> {\n    private Node<T> head;\n\n    // Constructor\n    public LinkedList() {\n        this.head = null;\n    }\n\n    // Method to insert a node at the beginning of the linked list\n    public void insertAtBeginning(T data) {\n        Node<T> newNode = new Node<>(data);\n        newNode.next = head;\n        head = newNode;\n    }\n\n    // Method to insert a node at the end of the linked list\n    public void insertAtEnd(T data) {\n        Node<T> newNode = new Node<>(data);\n        if (head == null) {\n            head = newNode;\n            return;\n        }\n        Node<T> current = head;\n        while (current.next != null) {\n            current = current.next;\n        }\n        current.next = newNode;\n    }\n\n    // Method to display the linked list\n    public void display() {\n        Node<T> current = head;\n        System.out.print("Linked List: ");\n        while (current != null) {\n            System.out.print(current.data + " ");\n            current = current.next;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        LinkedList<Integer> linkedList = new LinkedList<>();\n        \n        // Insert nodes at the beginning\n        linkedList.insertAtBeginning(3);\n        linkedList.insertAtBeginning(2);\n        linkedList.insertAtBeginning(1);\n        \n        // Display the linked list\n        linkedList.display();\n        \n        // Insert nodes at the end\n        linkedList.insertAtEnd(4);\n        linkedList.insertAtEnd(5);\n        \n        // Display the linked list\n        linkedList.display();\n\n        // Example with a different type (String)\n        LinkedList<String> stringLinkedList = new LinkedList<>();\n        stringLinkedList.insertAtBeginning("C");\n        stringLinkedList.insertAtBeginning("B");\n        stringLinkedList.insertAtBeginning("A");\n        stringLinkedList.display();\n        stringLinkedList.insertAtEnd("D");\n        stringLinkedList.insertAtEnd("E");\n        stringLinkedList.display();\n    }\n}\n',
    'import java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\n\npublic class MyPriorityQueue<T> {\n    private List<T> heap;\n    private Comparator<T> comparator;\n\n    public MyPriorityQueue(Comparator<T> comparator) {\n        this.heap = new ArrayList<>();\n        this.comparator = comparator;\n    }\n\n    public void offer(T element) {\n        heap.add(element);\n        bubbleUp(heap.size() - 1);\n    }\n\n    public T poll() {\n        if (isEmpty()) {\n            throw new IllegalStateException("Priority queue is empty");\n        }\n        T root = heap.get(0);\n        int lastIdx = heap.size() - 1;\n        heap.set(0, heap.get(lastIdx));\n        heap.remove(lastIdx);\n        if (!isEmpty()) {\n            bubbleDown(0);\n        }\n        return root;\n    }\n\n    public T peek() {\n        if (isEmpty()) {\n            throw new IllegalStateException("Priority queue is empty");\n        }\n        return heap.get(0);\n    }\n\n    public boolean isEmpty() {\n        return heap.isEmpty();\n    }\n\n    private void bubbleUp(int idx) {\n        while (idx > 0) {\n            int parentIdx = (idx - 1) / 2;\n            if (comparator.compare(heap.get(idx), heap.get(parentIdx)) > 0) {\n                swap(idx, parentIdx);\n                idx = parentIdx;\n            } else {\n                break;\n            }\n        }\n    }\n\n    private void bubbleDown(int idx) {\n        int size = heap.size();\n        while (true) {\n            int leftChildIdx = 2 * idx + 1;\n            int rightChildIdx = 2 * idx + 2;\n            int largestIdx = idx;\n\n            if (leftChildIdx < size && comparator.compare(heap.get(leftChildIdx), heap.get(largestIdx)) > 0) {\n                largestIdx = leftChildIdx;\n            }\n\n            if (rightChildIdx < size && comparator.compare(heap.get(rightChildIdx), heap.get(largestIdx)) > 0) {\n                largestIdx = rightChildIdx;\n            }\n\n            if (largestIdx != idx) {\n                swap(idx, largestIdx);\n                idx = largestIdx;\n            } else {\n                break;\n            }\n        }\n    }\n\n    private void swap(int i, int j) {\n        T temp = heap.get(i);\n        heap.set(i, heap.get(j));\n        heap.set(j, temp);\n    }\n\n    public static void main(String[] args) {\n        MyPriorityQueue<Integer> pq = new MyPriorityQueue<>(Comparator.naturalOrder());\n        pq.offer(10);\n        pq.offer(30);\n        pq.offer(20);\n        pq.offer(50);\n        pq.offer(40);\n\n        while (!pq.isEmpty()) {\n            System.out.println(pq.poll());\n        }\n    }\n}\n',
    '// Generic TreeNode class\nclass TreeNode<T extends Comparable<T>> {\n    T data;\n    TreeNode<T> left;\n    TreeNode<T> right;\n\n    // Constructor\n    public TreeNode(T data) {\n        this.data = data;\n        this.left = null;\n        this.right = null;\n    }\n}\n\n// Generic BinarySearchTree class\npublic class BinarySearchTree<T extends Comparable<T>> {\n    private TreeNode<T> root;\n\n    // Constructor\n    public BinarySearchTree() {\n        this.root = null;\n    }\n\n    // Method to insert a node into the binary search tree\n    public void insert(T data) {\n        root = insertRecursive(root, data);\n    }\n\n    private TreeNode<T> insertRecursive(TreeNode<T> root, T data) {\n        if (root == null) {\n            return new TreeNode<>(data);\n        }\n\n        if (data.compareTo(root.data) < 0) {\n            root.left = insertRecursive(root.left, data);\n        } else if (data.compareTo(root.data) > 0) {\n            root.right = insertRecursive(root.right, data);\n        }\n\n        return root;\n    }\n\n    // Method to search for a node in the binary search tree\n    public boolean search(T data) {\n        return searchRecursive(root, data);\n    }\n\n    private boolean searchRecursive(TreeNode<T> root, T data) {\n        if (root == null) {\n            return false;\n        }\n\n        if (data.compareTo(root.data) == 0) {\n            return true;\n        } else if (data.compareTo(root.data) < 0) {\n            return searchRecursive(root.left, data);\n        } else {\n            return searchRecursive(root.right, data);\n        }\n    }\n\n    // Method to delete a node from the binary search tree\n    public void delete(T data) {\n        root = deleteRecursive(root, data);\n    }\n\n    private TreeNode<T> deleteRecursive(TreeNode<T> root, T data) {\n        if (root == null) {\n            return null;\n        }\n\n        if (data.compareTo(root.data) < 0) {\n            root.left = deleteRecursive(root.left, data);\n        } else if (data.compareTo(root.data) > 0) {\n            root.right = deleteRecursive(root.right, data);\n        } else {\n            // Node to delete found\n\n            // Case 1: Node has no children\n            if (root.left == null && root.right == null) {\n                return null;\n            }\n\n            // Case 2: Node has one child\n            if (root.left == null) {\n                return root.right;\n            } else if (root.right == null) {\n                return root.left;\n            }\n\n            // Case 3: Node has two children\n            T minValue = findMinValue(root.right);\n            root.data = minValue;\n            root.right = deleteRecursive(root.right, minValue);\n        }\n\n        return root;\n    }\n\n    private T findMinValue(TreeNode<T> root) {\n        T minValue = root.data;\n        while (root.left != null) {\n            minValue = root.left.data;\n            root = root.left;\n        }\n        return minValue;\n    }\n\n    // Method to traverse the binary search tree (inorder traversal)\n    public void inorderTraversal() {\n        inorderTraversalRecursive(root);\n        System.out.println();\n    }\n\n    private void inorderTraversalRecursive(TreeNode<T> root) {\n        if (root != null) {\n            inorderTraversalRecursive(root.left);\n            System.out.print(root.data + " ");\n            inorderTraversalRecursive(root.right);\n        }\n    }\n\n    public static void main(String[] args) {\n        BinarySearchTree<Integer> bst = new BinarySearchTree<>();\n\n        // Insert elements into the binary search tree\n        bst.insert(50);\n        bst.insert(30);\n        bst.insert(70);\n        bst.insert(20);\n        bst.insert(40);\n        bst.insert(60);\n        bst.insert(80);\n\n        // Print inorder traversal of the binary search tree\n        System.out.print("Inorder Traversal: ");\n        bst.inorderTraversal();\n\n        // Search for an element in the binary search tree\n        int key = 40;\n        System.out.println("Search for " + key + ": " + bst.search(key));\n\n        // Delete an element from the binary search tree\n        bst.delete(30);\n        System.out.print("Inorder Traversal after deletion: ");\n        bst.inorderTraversal();\n\n        // Example with a different type (String)\n        BinarySearchTree<String> stringBST = new BinarySearchTree<>();\n        stringBST.insert("apple");\n        stringBST.insert("banana");\n        stringBST.insert("cherry");\n        stringBST.inorderTraversal();\n        System.out.println("Search for \'banana\': " + stringBST.search("banana"));\n        stringBST.delete("banana");\n        System.out.print("Inorder Traversal after deletion: ");\n        stringBST.inorderTraversal();\n    }\n}\n',
    'class LinearProbingHashTable {\n    private int[] table;\n    private int capacity;\n    private int size;\n\n    // Constructor to initialize the hash table\n    public LinearProbingHashTable(int capacity) {\n        this.capacity = capacity;\n        this.table = new int[capacity];\n        this.size = 0;\n    }\n\n    // Method to insert a key into the hash table using linear probing\n    public void insert(int key) {\n        if (size == capacity) {\n            System.out.println("Hash Table is full. Cannot insert " + key);\n            return;\n        }\n\n        int index = hash(key);\n        while (table[index] != 0) {\n            index = (index + 1) % capacity;\n        }\n        table[index] = key;\n        size++;\n        System.out.println("Inserted " + key + " at index " + index);\n    }\n\n    // Method to search for a key in the hash table\n    public int search(int key) {\n        int index = hash(key);\n        int originalIndex = index;\n        while (table[index] != key) {\n            index = (index + 1) % capacity;\n            if (index == originalIndex || table[index] == 0) {\n                return -1; // Key not found\n            }\n        }\n        return index; // Key found at index\n    }\n\n    // Method to delete a key from the hash table\n    public void delete(int key) {\n        int index = search(key);\n        if (index != -1) {\n            table[index] = 0;\n            size--;\n            System.out.println("Deleted " + key + " from index " + index);\n        } else {\n            System.out.println(key + " not found in the hash table");\n        }\n    }\n\n    // Method to calculate hash value\n    private int hash(int key) {\n        return key % capacity;\n    }\n\n    // Method to display the hash table\n    public void display() {\n        System.out.print("Hash Table: ");\n        for (int i = 0; i < capacity; i++) {\n            System.out.print(table[i] + " ");\n        }\n        System.out.println();\n    }\n}\n\npublic class LinearProbingExample {\n    public static void main(String[] args) {\n        // Create a hash table with capacity 10\n        LinearProbingHashTable hashTable = new LinearProbingHashTable(10);\n\n        // Insert elements into the hash table\n        hashTable.insert(5);\n        hashTable.insert(25);\n        hashTable.insert(15);\n        hashTable.insert(35);\n        hashTable.insert(45);\n\n        // Display the hash table\n        hashTable.display();\n\n        // Search for a key in the hash table\n        int key = 15;\n        int index = hashTable.search(key);\n        if (index != -1) {\n            System.out.println(key + " found at index " + index);\n        } else {\n            System.out.println(key + " not found in the hash table");\n        }\n\n        // Delete a key from the hash table\n        hashTable.delete(15);\n\n        // Display the hash table after deletion\n        hashTable.display();\n    }\n}\n',
    'class Queue {\n    private int[] array;\n    private int front;\n    private int rear;\n    private int capacity;\n    private int size;\n\n    // Constructor to initialize the queue\n    public Queue(int capacity) {\n        this.capacity = capacity;\n        this.array = new int[capacity];\n        this.front = 0;\n        this.rear = -1;\n        this.size = 0;\n    }\n\n    // Method to enqueue an element into the queue\n    public void enqueue(int data) {\n        if (isFull()) {\n            System.out.println("Queue Overflow. Cannot enqueue " + data);\n            return;\n        }\n        rear = (rear + 1) % capacity;\n        array[rear] = data;\n        size++;\n        System.out.println(data + " enqueued to queue");\n    }\n\n    // Method to dequeue an element from the queue\n    public int dequeue() {\n        if (isEmpty()) {\n            System.out.println("Queue Underflow. Cannot dequeue from an empty queue");\n            return -1;\n        }\n        int dequeuedData = array[front];\n        front = (front + 1) % capacity;\n        size--;\n        return dequeuedData;\n    }\n\n    // Method to check if the queue is empty\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    // Method to check if the queue is full\n    public boolean isFull() {\n        return size == capacity;\n    }\n}\n\npublic class QueueUsingArray {\n    public static void main(String[] args) {\n        // Create a queue with capacity 5\n        Queue queue = new Queue(5);\n\n        // Enqueue elements into the queue\n        queue.enqueue(10);\n        queue.enqueue(20);\n        queue.enqueue(30);\n        queue.enqueue(40);\n        queue.enqueue(50);\n\n        // Dequeue elements from the queue\n        System.out.println("Dequeued element: " + queue.dequeue());\n        System.out.println("Dequeued element: " + queue.dequeue());\n\n        // Enqueue another element\n        queue.enqueue(60);\n\n        // Dequeue elements until the queue is empty\n        while (!queue.isEmpty()) {\n            System.out.println("Dequeued element: " + queue.dequeue());\n        }\n\n        // Dequeue from an empty queue\n        System.out.println("Dequeued element: " + queue.dequeue());\n    }\n}\n',
    '// Generic Node class\nclass Node<T> {\n    T data;\n    Node<T> next;\n\n    // Constructor\n    public Node(T data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\n// Generic Queue class\nclass Queue<T> {\n    private Node<T> front;\n    private Node<T> rear;\n\n    // Constructor to initialize the queue\n    public Queue() {\n        this.front = null;\n        this.rear = null;\n    }\n\n    // Method to enqueue an element into the queue\n    public void enqueue(T data) {\n        Node<T> newNode = new Node<>(data);\n        if (rear == null) {\n            front = rear = newNode;\n            System.out.println(data + " enqueued to queue");\n            return;\n        }\n        rear.next = newNode;\n        rear = newNode;\n        System.out.println(data + " enqueued to queue");\n    }\n\n    // Method to dequeue an element from the queue\n    public T dequeue() {\n        if (isEmpty()) {\n            System.out.println("Queue Underflow. Cannot dequeue from an empty queue");\n            return null;\n        }\n        T dequeuedData = front.data;\n        front = front.next;\n        if (front == null) {\n            rear = null;\n        }\n        return dequeuedData;\n    }\n\n    // Method to check if the queue is empty\n    public boolean isEmpty() {\n        return front == null;\n    }\n}\n\npublic class QueueUsingLinkedList {\n    public static void main(String[] args) {\n        // Create a queue of integers\n        Queue<Integer> intQueue = new Queue<>();\n\n        // Enqueue elements into the queue\n        intQueue.enqueue(10);\n        intQueue.enqueue(20);\n        intQueue.enqueue(30);\n\n        // Dequeue elements from the queue\n        System.out.println("Dequeued element: " + intQueue.dequeue());\n        System.out.println("Dequeued element: " + intQueue.dequeue());\n\n        // Enqueue another element\n        intQueue.enqueue(40);\n\n        // Dequeue elements until the queue is empty\n        while (!intQueue.isEmpty()) {\n            System.out.println("Dequeued element: " + intQueue.dequeue());\n        }\n\n        // Dequeue from an empty queue\n        System.out.println("Dequeued element: " + intQueue.dequeue());\n\n        // Create a queue of strings\n        Queue<String> stringQueue = new Queue<>();\n\n        // Enqueue elements into the queue\n        stringQueue.enqueue("Alice");\n        stringQueue.enqueue("Bob");\n        stringQueue.enqueue("Charlie");\n\n        // Dequeue elements from the queue\n        System.out.println("Dequeued element: " + stringQueue.dequeue());\n        System.out.println("Dequeued element: " + stringQueue.dequeue());\n\n        // Enqueue another element\n        stringQueue.enqueue("Dave");\n\n        // Dequeue elements until the queue is empty\n        while (!stringQueue.isEmpty()) {\n            System.out.println("Dequeued element: " + stringQueue.dequeue());\n        }\n\n        // Dequeue from an empty queue\n        System.out.println("Dequeued element: " + stringQueue.dequeue());\n    }\n}\n',
    '// Generic Node class\nclass Node<T extends Comparable<T>> {\n    T data;\n    Node<T> next;\n\n    // Constructor\n    public Node(T data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\n// Generic SortedChain class\nclass SortedChain<T extends Comparable<T>> {\n    private Node<T> head;\n\n    // Constructor to initialize the sorted chain\n    public SortedChain() {\n        this.head = null;\n    }\n\n    // Method to insert a node into the sorted chain\n    public void insert(T data) {\n        Node<T> newNode = new Node<>(data);\n        if (head == null || data.compareTo(head.data) < 0) {\n            newNode.next = head;\n            head = newNode;\n        } else {\n            Node<T> current = head;\n            while (current.next != null && current.next.data.compareTo(data) < 0) {\n                current = current.next;\n            }\n            newNode.next = current.next;\n            current.next = newNode;\n        }\n    }\n\n    // Method to display the sorted chain\n    public void display() {\n        Node<T> current = head;\n        System.out.print("Sorted Chain: ");\n        while (current != null) {\n            System.out.print(current.data + " ");\n            current = current.next;\n        }\n        System.out.println();\n    }\n}\n\npublic class SortedChainExample {\n    public static void main(String[] args) {\n        // Create a sorted chain of integers\n        SortedChain<Integer> intChain = new SortedChain<>();\n\n        // Insert elements into the sorted chain\n        intChain.insert(30);\n        intChain.insert(10);\n        intChain.insert(20);\n        intChain.insert(50);\n        intChain.insert(40);\n\n        // Display the sorted chain\n        intChain.display();\n\n        // Create a sorted chain of strings\n        SortedChain<String> stringChain = new SortedChain<>();\n\n        // Insert elements into the sorted chain\n        stringChain.insert("Charlie");\n        stringChain.insert("Alice");\n        stringChain.insert("Bob");\n        stringChain.insert("Eve");\n        stringChain.insert("David");\n\n        // Display the sorted chain\n        stringChain.display();\n    }\n}\n',
    'import java.util.ArrayList;\n\nclass Stack {\n    private ArrayList<Integer> stack;\n\n    // Constructor to initialize the stack\n    public Stack() {\n        stack = new ArrayList<>();\n    }\n\n    // Method to push an element onto the stack\n    public void push(int element) {\n        stack.add(element);\n    }\n\n    // Method to pop an element from the stack\n    public int pop() {\n        if (isEmpty()) {\n            System.out.println("Stack underflow. Cannot pop from an empty stack.");\n            return -1;\n        }\n        return stack.remove(stack.size() - 1);\n    }\n\n    // Method to peek at the top element of the stack\n    public int peek() {\n        if (isEmpty()) {\n            System.out.println("Stack is empty. Cannot peek.");\n            return -1;\n        }\n        return stack.get(stack.size() - 1);\n    }\n\n    // Method to check if the stack is empty\n    public boolean isEmpty() {\n        return stack.isEmpty();\n    }\n\n    // Method to display the elements of the stack\n    public void display() {\n        if (isEmpty()) {\n            System.out.println("Stack is empty.");\n            return;\n        }\n        System.out.print("Stack (top to bottom): ");\n        for (int i = stack.size() - 1; i >= 0; i--) {\n            System.out.print(stack.get(i) + " ");\n        }\n        System.out.println();\n    }\n}\n\npublic class StackUsingArrayList {\n    public static void main(String[] args) {\n        // Create a stack\n        Stack stack = new Stack();\n\n        // Push elements onto the stack\n        stack.push(10);\n        stack.push(20);\n        stack.push(30);\n        stack.push(40);\n\n        // Display the stack\n        stack.display();\n\n        // Peek at the top element\n        System.out.println("Top element: " + stack.peek());\n\n        // Pop an element\n        System.out.println("Popped element: " + stack.pop());\n\n        // Display the stack after popping\n        stack.display();\n    }\n}\n',
    'class Stack {\n    private int[] array;\n    private int top;\n    private int capacity;\n\n    // Constructor to initialize the stack\n    public Stack(int capacity) {\n        this.capacity = capacity;\n        this.array = new int[capacity];\n        this.top = -1;\n    }\n\n    // Method to push an element onto the stack\n    public void push(int data) {\n        if (isFull()) {\n            System.out.println("Stack Overflow. Cannot push " + data);\n            return;\n        }\n        array[++top] = data;\n        System.out.println(data + " pushed to stack");\n    }\n\n    // Method to pop an element from the stack\n    public int pop() {\n        if (isEmpty()) {\n            System.out.println("Stack Underflow. Cannot pop from an empty stack");\n            return -1;\n        }\n        return array[top--];\n    }\n\n    // Method to peek at the top element of the stack\n    public int peek() {\n        if (isEmpty()) {\n            System.out.println("Stack is empty. Cannot peek");\n            return -1;\n        }\n        return array[top];\n    }\n\n    // Method to check if the stack is empty\n    public boolean isEmpty() {\n        return top == -1;\n    }\n\n    // Method to check if the stack is full\n    public boolean isFull() {\n        return top == capacity - 1;\n    }\n}\n\npublic class StackUsingArray {\n    public static void main(String[] args) {\n        // Create a stack with capacity 5\n        Stack stack = new Stack(5);\n\n        // Push elements onto the stack\n        stack.push(10);\n        stack.push(20);\n        stack.push(30);\n\n        // Display the top element of the stack\n        System.out.println("Top element: " + stack.peek());\n\n        // Pop elements from the stack\n        System.out.println("Popped element: " + stack.pop());\n        System.out.println("Popped element: " + stack.pop());\n        System.out.println("Popped element: " + stack.pop());\n\n        // Pop from an empty stack\n        System.out.println("Popped element: " + stack.pop());\n    }\n}\n',
    '// Generic Node class\nclass Node<T> {\n    T data;\n    Node<T> next;\n\n    // Constructor\n    public Node(T data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\n// Generic Stack class\nclass Stack<T> {\n    private Node<T> top;\n\n    // Constructor to initialize the stack\n    public Stack() {\n        this.top = null;\n    }\n\n    // Method to push an element onto the stack\n    public void push(T data) {\n        Node<T> newNode = new Node<>(data);\n        newNode.next = top;\n        top = newNode;\n        System.out.println(data + " pushed to stack");\n    }\n\n    // Method to pop an element from the stack\n    public T pop() {\n        if (isEmpty()) {\n            System.out.println("Stack Underflow. Cannot pop from an empty stack");\n            return null;\n        }\n        T poppedData = top.data;\n        top = top.next;\n        return poppedData;\n    }\n\n    // Method to peek at the top element of the stack\n    public T peek() {\n        if (isEmpty()) {\n            System.out.println("Stack is empty. Cannot peek");\n            return null;\n        }\n        return top.data;\n    }\n\n    // Method to check if the stack is empty\n    public boolean isEmpty() {\n        return top == null;\n    }\n}\n\npublic class StackUsingLinkedList {\n    public static void main(String[] args) {\n        // Create a stack of integers\n        Stack<Integer> intStack = new Stack<>();\n\n        // Push elements onto the stack\n        intStack.push(10);\n        intStack.push(20);\n        intStack.push(30);\n\n        // Display the top element of the stack\n        System.out.println("Top element: " + intStack.peek());\n\n        // Pop elements from the stack\n        System.out.println("Popped element: " + intStack.pop());\n        System.out.println("Popped element: " + intStack.pop());\n        System.out.println("Popped element: " + intStack.pop());\n\n        // Pop from an empty stack\n        System.out.println("Popped element: " + intStack.pop());\n\n        // Create a stack of strings\n        Stack<String> stringStack = new Stack<>();\n\n        // Push elements onto the stack\n        stringStack.push("Alice");\n        stringStack.push("Bob");\n        stringStack.push("Charlie");\n\n        // Display the top element of the stack\n        System.out.println("Top element: " + stringStack.peek());\n\n        // Pop elements from the stack\n        System.out.println("Popped element: " + stringStack.pop());\n        System.out.println("Popped element: " + stringStack.pop());\n        System.out.println("Popped element: " + stringStack.pop());\n\n        // Pop from an empty stack\n        System.out.println("Popped element: " + stringStack.pop());\n    }\n}\n',
    'import java.util.HashSet;\nimport java.util.Iterator;\n\npublic class HashSetOperations {\n    public static void main(String[] args) {\n        // Create a HashSet\n        HashSet<String> hashSet = new HashSet<>();\n\n        // Add elements to the HashSet\n        hashSet.add("Apple");\n        hashSet.add("Banana");\n        hashSet.add("Orange");\n        hashSet.add("Grapes");\n\n        // Display the elements of the HashSet using iterator\n        System.out.println("HashSet elements:");\n        Iterator<String> iterator = hashSet.iterator();\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next());\n        }\n\n        // Remove an element from the HashSet\n        String removedElement = "Banana";\n        hashSet.remove(removedElement);\n        System.out.println("\\nAfter removing \'" + removedElement + "\':");\n        displayHashSet(hashSet);\n    }\n\n    // Method to display elements of the HashSet\n    public static void displayHashSet(HashSet<String> hashSet) {\n        System.out.println("HashSet elements:");\n        for (String element : hashSet) {\n            System.out.println(element);\n        }\n    }\n}\n'
    ]

answers.Add("ADSJanswers", ADSJanswers);


subjects.Add("SEDEVOPS", [
    "uml diagrams",
    "jenkins",
    "maven",
    "git",
    "junit",
    "testcase"
]);
var SEDEVOPSanswers = [
    "Please go to  https://rok-143.web.app/devops/uml/ there you'll find all uml diagrams    OR ELSE  \n  you can download the docx by adding uml.docx to the link ",
    "Please go to  https://rok-143.web.app/devops/jenkins/   OR ELSE   \n  you can download the docx by adding jenkins.docx to the link",
    "Please go to  https://rok-143.web.app/devops/maven/    OR ELSE  \n  you can download the docx by adding maven.docx to the link",
    "Please go to  https://rok-143.web.app/devops/git/   OR ELSE  \n  you can download the docx by adding git.docx to the link",
    "Please go to  https://rok-143.web.app/devops/junit/    OR ELSE \n  you can download the docx by adding junit.docx to the link",
    "Please go to  https://rok-143.web.app/devops/testcase/ "
];
    answers.Add("SEDEVOPSanswers", SEDEVOPSanswers);


var a;
var b;

WScript.StdOut.WriteLine("Enter Password:");
pass = WScript.StdIn.ReadLine();
if (pass!="rok")
    WScript.Quit();

WScript.StdOut.WriteBlankLines(100)
WScript.StdOut.WriteLine(" ____  ___ _  _______ _____ \n|  _ \\|_ _| |/ / ____| ____|\n| |_) || || ' /|  _| |  _|  \n|  _ < | || . \\| |___| |___ \n|_| \\_\\___|_|\\_\\_____|_____|\n                            \n")


while (true) {
    WScript.StdOut.WriteLine("----- Subjects -----");
    a = (new VBArray(subjects.Keys())).toArray();
    b = (new VBArray(subjects.Items())).toArray();
    for (var subjectIndex = 0; subjectIndex < subjects.Count; subjectIndex++) {
        WScript.StdOut.WriteLine(subjectIndex + 1 + ". " + a[subjectIndex]);
    }

    var selectedSubjectIndex = WScript.StdIn.ReadLine();

    if (selectedSubjectIndex.toLowerCase() === "exit") {
        WScript.Quit();
    }

    if (!isNaN(selectedSubjectIndex)) {
        selectedSubjectIndex = parseInt(selectedSubjectIndex, 10);
        if (selectedSubjectIndex >= 1 && selectedSubjectIndex <= subjects.Count) {
            var selectedSubject = a[selectedSubjectIndex - 1];
            DisplayQuestions(selectedSubject);
        } else {
            WScript.StdOut.WriteLine("Invalid subject number. Please try again.");
        }
    } else {
        WScript.StdOut.WriteLine("Invalid input. Please enter a numeric subject number or 'exit' to end.");
    }
}

function DisplayQuestions(subject) {
    do {
        var questionsArray;
        var answersArray;

        switch (subject) {
            case "SEDEVOPS":
                questionsArray = subjects.Item("SEDEVOPS");
                answersArray = answers.Item("SEDEVOPSanswers");
                break;
            case "ADSJ":
                questionsArray = subjects.Item("ADSJ");
                answersArray = answers.Item("ADSJanswers");
                break;
        }

        WScript.StdOut.WriteLine("----- " + subject + " Questions -----");
        for (var i = 0; i < questionsArray.length; i++) {
            WScript.StdOut.WriteLine(i + 1 + ". " + questionsArray[i]);
        }

        var userInput = WScript.StdIn.ReadLine();
        if (userInput.toLowerCase() === "exit") {
            break;
        }

        if (!isNaN(userInput)) {
            var questionNumber = parseInt(userInput, 10);

            if (questionNumber >= 1 && questionNumber <= questionsArray.length) {
                WScript.StdOut.WriteLine("Answer: \n\n----------------------------------------------- \n\n" + answersArray[questionNumber - 1] + "\n\n------------------------------------------- \n");
                WScript.StdIn.ReadLine();
            } else {
                WScript.StdOut.WriteLine("Invalid question number. Please try again.");
            }
        } else {
            WScript.StdOut.WriteLine("Invalid input. Please enter a numeric question number or 'exit' to go back.");
        }
    } while (true);
}
